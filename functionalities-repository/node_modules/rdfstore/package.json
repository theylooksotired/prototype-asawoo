{
  "name": "rdfstore",
  "version": "0.9.4",
  "description": "RDF graph store supporting the SPARQL query language",
  "keywords": [
    "RDF",
    "SPARQL",
    "graph",
    "store"
  ],
  "author": {
    "name": "Antonio Garrote",
    "email": "<antoniogarrote@gmail.com"
  },
  "engines": {
    "node": ">=0.6.1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/antoniogarrote/rdfstore-js.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  ],
  "main": "src/store",
  "devDependencies": {
    "async": "^0.9.0",
    "lodash": "^2.4.1",
    "bower-resolve": "^2.2.1",
    "browserify": "7.0.0",
    "closure-compiler": "^0.2.6",
    "debowerify": "^1.2.0",
    "gulp": "3.8.10",
    "gulp-browserify": "^0.5.1",
    "gulp-closure-compiler": "^0.2.17",
    "gulp-jasmine": "^1.0.1",
    "gulp-rename": "^1.2.0",
    "pegjs": "^0.8.0",
    "moment": "^2.9.0",
    "vinyl-source-stream": "^1.0.0"
  },
  "dependencies": {
    "sqlite3": "^3.0.5",
    "indexeddb-js": "0.0.14",
    "jsonld": "^0.3.22",
    "n3": "^0.4.2"
  },
  "readme": "#rdfstore-js [![Build Status](https://travis-ci.org/antoniogarrote/rdfstore-js.svg?branch=master)](https://travis-ci.org/antoniogarrote/rdfstore-js)\n\n## Important Note\n\nThe library is going right now through a major rewrite. Versions > 0.9.X must be considered development versions until version 1.0.0 is finished.\nMany features present in versions 0.8.X have been removed. Some of them, will be added in the next versions, other like the MongoDB backend will be discarded.\n\nPlease read this README file carefully to find the current set of features.\n\n## Introduction\n\nrdfstore-js is a pure Javascript implementation of a RDF graph store with support for the SPARQL query and data manipulation language.\n```javascript\nvar rdfstore = require('rdfstore');\n    \nrdfstore.create(function(err, store) {\n  store.execute('LOAD <http://dbpedia.org/resource/Tim_Berners-Lee> INTO GRAPH <http://example.org/people>', function() {\n\n    store.setPrefix('dbp', 'http://dbpedia.org/resource/');\n        \n    store.node(store.rdf.resolve('dbp:Tim_Berners-Lee'),  \"http://example.org/people\", function(err, graph) {\n\n      var peopleGraph = graph.filter(store.rdf.filters.type(store.rdf.resolve(\"foaf:Person\")));\n          \n      store.execute('PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\\n                     PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\\n                     PREFIX : <http://example.org/>\\\n                     SELECT ?s FROM NAMED :people { GRAPH ?g { ?s rdf:type foaf:Person } }',\n                     function(err, results) {\n\n                       console.log(peopleGraph.toArray()[0].subject.valueOf() === results[0].s.value);\n\n                     });\n    });\n\n  });\n});\n```\n    \nrdfstore-js can be executed in a web browser or can be included as a library in a node.js application. It can also be executed as a stand-alone SPARQL end-point accepting SPARQL RDF Protocol HTTP requests. Go to the bottom of this page to find some application examples using the library.\n\nThe current implementation is far from complete but it already passes all the test cases for the SPARQL 1.0 query language and supports data manipulation operations from the SPARQL 1.1/Update version of the language.\n\nSome other features included in the library are the following:\n\n- SPARQL 1.0 support\n- SPARQL 1.1/Update support\n- Partial SPARQL 1.1 query support\n- JSON-LD parser\n- Turtle/N3 parser\n- W3C RDF Interfaces API\n- RDF graph events API\n- Custom filter functions\n- Browser persistence using IndexedDB\n\n## Documentation\n\nDocumentation for the store can be found [here](http://antoniogarrote.github.com/rdfstore-js/doc/index.html).\n\n## SPARQL support\n\nrdfstore-js supports at the moment SPARQL 1.0 and most of SPARQL 1.1/Update.\nOnly some parts of SPARQL 1.1 query have been implemented yet.\n\nThis is a list of the different kind of queries currently implemented:\n  \n- SELECT queries\n- UNION, OPTIONAL clauses\n- NAMED GRAPH identifiers\n- LIMIT, OFFSET\n- ORDER BY clauses\n- SPARQL 1.0 filters and builtin functions\n- variable aliases\n- variable aggregation: MAX, MIN, COUNT, AVG, SUM functions\n- GROUP BY clauses\n- DISTINCT query modifier\n- CONSTRUCT queries\n- ASK queries\n- INSERT DATA queries\n- DELETE DATA queries\n- DELETE WHERE queries\n- WITH/DELETE/INSERT/WHERE queries\n- LOAD queries\n- CREATE GRAPH clauses\n- DROP DEFAULT/NAMED/ALL/GRAPH clauses\n- CLEAR DEFAULT/NAMED/ALL/Graph clauses\n- FILTER EXISTS / NOT EXISTS operators\n- FILTER IN / NOT IN operators\n\n\n##Installation\n\nThe library can be installed using NPM:\n\n```bash\n$ npm install rdfstore\n```\n\nBower package will be pusblished for the library soon.\n\n##Building\n\nBefore running the build script, you must install JavaScript dependencies with [npm](https://npmjs.org/doc/install.html) (`npm` is shipped with [node](http://nodejs.org/download/)):\n\n```bash\n$ npm install\n```\n    \nThe library can be built using gulp:\n\n```bash\n$ gulp\n```\n\n## Tests\n\nTo execute the whole test suite of the library, including the DAWG\ntest cases for SPARQL 1.0 and the test cases for SPARQL 1.1\nimplemented at the moment, a gulp target can be executed:\n\n```bash\n$ gulp specs\n```\n\nAdditionally, there are some smoke tests for both browser versions that can be found ithe 'spec/browser'' directory.\n\n## API\n\nThis is a small overview of the rdfstore-js API.\n\n###Store creation\n\n```javascript\n//nodejs only\nvar rdfstore = require('rdfstore');\n\n// in the browser the rdfstore object\n// is already defined\n\n// alt 1\nrdfstore.create(function(err, store) {\n  // the new store is ready\n});\n\n\n// alt 2\nnew rdfstore.Store(function(err, store) {\n  // the new store is ready\n});\n```\n\n###Query execution\n\n```javascript\n// simple query execution\nstore.execute(\"SELECT * { ?s ?p ?o }\", function(err, results){\n  if(!err) {\n    // process results        \n    if(results[0].s.token === 'uri') {\n      console.log(results[0].s.value);\n    }       \n  }\n});\n\n// execution with an explicit default and named graph\n\nvar defaultGraph = [{'token':'uri', 'value': graph1}, {'token':'uri', 'value': graph2}, ...];\nvar namedGraphs  = [{'token':'uri', 'value': graph3}, {'token':'uri', 'value': graph4}, ...];\n\nstore.executeWithEnvironment(\"SELECT * { ?s ?p ?o }\",defaultGraph,\n  namedGraphs, function(err, results) {\n  if(err) {\n    // process results\n  }\n});\n```\n    \n###Construct queries RDF Interfaces API\n\n```javascript\nvar query = \"CONSTRUCT { <http://example.org/people/Alice> ?p ?o } \\\n             WHERE { <http://example.org/people/Alice> ?p ?o  }\";\n\nstore.execute(query, function(err, graph){\n  if(graph.some(store.rdf.filters.p(store.rdf.resolve('foaf:name)))) {\n    nameTriples = graph.match(null, \n                              store.rdf.createNamedNode(rdf.resolve('foaf:name')),\n                              null);\n\n    nameTriples.forEach(function(triple) {\n      console.log(triple.object.valueOf());\n    });                                  \n  }\n});\n```\n\n###Loading remote graphs\n\nrdfstore-js will try to retrieve remote RDF resources across the network when a 'LOAD' SPARQL query is executed.\nThe node.js build of the library will use regular TCP sockets and perform proper content negotiation. It will also follow a limited number of redirections.\nThe browser build, will try to perform an AJAX request to retrieve the resource using the correct HTTP headers. Nevertheless, this implementation is subjected to the limitations of the Same Domain Policy implemented in current browsers that prevents cross domain requests. Redirections, even for the same domain, may also fail due to the browser removing the 'Accept' HTTP header of the original request.\nrdfstore-js relies in on the jQuery Javascript library to peform cross-browser AJAX requests. This library must be linked in order to exeucte 'LOAD' requests in the browser.  \n\n```javascript\nstore.execute('LOAD <http://dbpedialite.org/titles/Lisp_%28programming_language%29>\\\n               INTO GRAPH <lisp>', function(err){\n  if(err) {\n    var query = 'PREFIX foaf:<http://xmlns.com/foaf/0.1/> SELECT ?o \\\n                 FROM NAMED <lisp> { GRAPH <lisp> { ?s foaf:page ?o} }';\n    store.execute(query, function(err, results) {\n      // process results\n    });\n  }\n})\n```\n    \n###High level interface\n\nThe following interface is a convenience API to work with Javascript code instead of using SPARQL query strings. It is built on top of the RDF Interfaces W3C API.\n\n```javascript\n/* retrieving a whole graph as JS Interafce API graph object */\n\nstore.graph(graphUri, function(graph){\n  // process graph\n});\n\n\n/* Exporting a graph to N3 (this function is not part of W3C's API)*/\nstore.graph(graphUri, function(graph){\n  var serialized = graph.toNT();\n});\n\n     \n/* retrieving a single node in the graph as a JS Interface API graph object */\n\nstore.node(subjectUri, function(graph) {\n  //process node\n});\n     \nstore.node(subjectUri, graphUri, function(graph) {\n  //process node\n});\n\n\n     \n/* inserting a JS Interface API graph object into the store */\n\n// inserted in the default graph\nstore.insert(graph, function(err) {}) ;\n\n// inserted in graphUri\nstore.insert(graph, graphUri, function(err) {}) ;\n\n\n\n/* deleting a JS Interface API graph object into the store */\n\n// deleted from the default graph\nstore.delete(graph, function(err){});\n\n// deleted from graphUri\nstore.delete(graph, graphUri, function(err){});\n\n\n\n/* clearing a graph */\n    \n// clears the default graph\nstore.clear(function(err){});\n\n// clears a named graph\nstore.clear(graphUri, function(err){});\n\n\n\n/* Parsing and loading a graph */\n\n// loading local data\nstore.load(\"text/turtle\", turtleString, function(err, results) {});\n\n// loading remote data\nstore.load('remote', remoteGraphUri, function(err, results) {});\n\n\n\n/* Registering a parser for a new media type */\n\n// The parser object must implement a 'parse' function\n// accepting the data to parse and a callback function.\n\nstore.registerParser(\"application/rdf+xml\", rdXmlParser);\n```\n    \n###RDF Interface API\n\nThe store object includes a 'rdf' object implementing a RDF environment as described in the [RDF Interfaces 1.0](http://www.w3.org/TR/rdf-interfaces/) W3C's working draft.\nThis object can be used to access to the full RDF Interfaces 1.0 API.\n\n```javascript\nvar graph = store.rdf.createGraph();\ngraph.addAction(rdf.createAction(store.rdf.filters.p(store.rdf.resolve(\"foaf:name\")),\n                                 function(triple){ var name = triple.object.valueOf();\n                                                   var name = name.slice(0,1).toUpperCase() \n                                                   + name.slice(1, name.length);\n                                                   triple.object = store.rdf.createNamedNode(name);\n                                                   return triple;}));\n\nstore.rdf.setPrefix(\"ex\", \"http://example.org/people/\");\ngraph.add(store.rdf.createTriple( store.rdf.createNamedNode(store.rdf.resolve(\"ex:Alice\")),\n                                  store.rdf.createNamedNode(store.rdf.resolve(\"foaf:name\")),\n                                  store.rdf.createLiteral(\"alice\") ));\n\nvar triples = graph.match(null, store.rdf.createNamedNode(store.rdf.resolve(\"foaf:name\")), null).toArray();\n\nconsole.log(\"worked? \"+(triples[0].object.valueOf() === 'Alice'));\n```\n    \n###Default Prefixes\n\nDefault RDF name-spaces can be specified using the *registerDefaultNamespace*. These names will be included automatically in all queries. If the same name-space is specified by the client in the query string the new prefix will shadow the default one.\nA collection of common name-spaces like rdf, rdfs, foaf, etc. can be automatically registered using the *registerDefaultProfileNamespace* function.\n\n```javascript\nnew Store({name:'test', overwrite:true}, function(err,store){\n    store.execute('INSERT DATA {  <http://example/person1> <http://xmlns.com/foaf/0.1/name> \"Celia\" }', function(err){\n\n       store.registerDefaultProfileNamespaces();\n\n       store.execute('SELECT * { ?s foaf:name ?name }', function(err,results) {\n           test.ok(results.length === 1);\n           test.ok(results[0].name.value === \"Celia\");\n       });\n    });\n});\n```\n\n###JSON-LD Support\n\nrdfstore-js implements parsers for Turtle and JSON-LD. The specification of JSON-LD is still an ongoing effort. You may expect to find some inconsistencies between this implementation and the actual specification.\n\n```javascript\n        jsonld = {\n          \"@context\": \n          {  \n             \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n             \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n             \"name\": \"http://xmlns.com/foaf/0.1/name\",\n             \"age\": {\"@id\": \"http://xmlns.com/foaf/0.1/age\", \"@type\": \"xsd:integer\" },\n             \"homepage\": {\"@id\": \"http://xmlns.com/foaf/0.1/homepage\", \"@type\": \"xsd:anyURI\" },\n             \"ex\": \"http://example.org/people/\"\n          },\n          \"@id\": \"ex:john_smith\",\n          \"name\": \"John Smith\",\n          \"age\": \"41\",\n          \"homepage\": \"http://example.org/home/\"\n        };    \n\nstore.setPrefix(\"ex\", \"http://example.org/people/\");\n\nstore.load(\"application/ld+json\", jsonld, \"ex:test\", function(err,results) {\n  store.node(\"ex:john_smith\", \"ex:test\", function(err, graph) {\n    // process graph here\n  });\n});\n```\n    \n###Events API\n\nrdfstore-js implements an experimental events API that allows clients to observe changes in the RDF graph and receive notifications when parts of this graph changes.\nThe two main event functions are *subscribe* that makes possible to set up a callback function that will be invoked each time triples matching a certain pattern passed as an argument are added or removed, and the function *startObservingNode* that will be invoked with the modified version of the node each time triples are added or removed from the node.\n\n```javascript\nvar cb = function(event, triples){ \n  // it will receive a notifications where a triple matching\n  // the pattern s:http://example/boogk, p:*, o:*, g:*\n  // is inserted or removed.\n  if(event === 'added') {\n    console.log(triples.length+\" triples have been added\");  \n  } else if(event === 'deleted') {\n    console.log(triples.length+\" triples have been deleted\");  \n  } \n}\n     \nstore.subscribe(\"http://example/book\",null,null,null,cb);\n     \n     \n// .. do something;\n     \n// stop receiving notifications\nstore.unsubscribe(cb);\n```\n    \nThe main difference between both methods is that *subscribe* receives the triples that have changed meanwhile *startObservingNode* receives alway the whole node with its updated triples. *startObservingNode* receives the node as a RDF Interface graph object.\n\n```javascript\nvar cb = function(node){ \n  // it will receive the updated version of the node each\n  // time it is modified.\n  // If the node does not exist, the graph received will\n  // not contain triples.\n  console.log(\"The node has now \"+node.toArray().length+\" nodes\");\n}\n     \n// if only tow arguments are passed, the default graph will be used.\n// A graph uri can be passed as an optional second argument.\nstore.startObservingNode(\"http://example/book\",cb);\n     \n     \n// .. do something;\n     \n// stop receiving notifications\nstore.stopObservingNode(cb);\n```\n\nIn the same way, there are *startObservingQuery* and *stopObservingQuery* functions that makes possible to set up callbacks for whole SPARQL queries. \nThe store will try to be smart and not perform unnecessary evaluations of these query after quad insertion/deletions. Nevertheless too broad queries must be used carefully with the events API.\n\n###Custom Filter Functions\n\nCustom filter function can be registered into the store using the *registerCustomFunction* function. This function receives two argument, the name of the custom function and the associated implementation. This functions will be available in a SPARQL query using the prefix *custom*.\nThe function implementation will receive two arguments, an object linking to the store query filters engine and a list with the actual arguments. Arguments will consist of literal or URIs objects. Results from the function must also be literal or URI objects.\n\nThe query filters engine can be used to access auxiliary function to transform literals into JavaScript types using the *effectiveTypeValue* function, boolean values using the *effectiveBooleanValue*, to build boolean litearl objects (*ebvTrue*, *ebvFalse*) or return an error with the *ebvError*. Documentation and source code for the *QueryFilters* object n the 'js-query-engine' module can be consulted to find information about additional helper functions.\n\nThe following test shows a simple examples of how custom functions can be invoked:\n\n```javascript\nnew Store({name:'test', overwrite:true}, function(err,store) {\n    store.load(\n        'text/n3',\n        '@prefix test: <http://test.com/> .\\\n         test:A test:prop 5.\\\n         test:B test:prop 4.\\\n         test:C test:prop 1.\\\n         test:D test:prop 3.',\n        function(err) {\n\n            var invoked = false;\n            store.registerCustomFunction('my_addition_check', function(engine,args) {\n\t    // equivalent to var v1 = parseInt(args[0].value), v2 = parseInt(args[1]);\n\n\t    var v1 = engine.effectiveTypeValue(args[0]);\n\t    var v2 = engine.effectiveTypeValue(args[1]);\n\n\t    // equivalent to return {token: 'literal', type:\"http://www.w3.org/2001/XMLSchema#boolean\", value:(v1+v2<5)};\n\n\t    return engine.ebvBoolean(v1+v2<5);\n\t});\n\n       store.execute(\n                'PREFIX test: <http://test.com/> \\\n                 SELECT * { ?x test:prop ?v1 .\\\n                            ?y test:prop ?v2 .\\\n                            filter(custom:my_addition_check(?v1,?v2)) }',\n                function(err) {\n                   test.ok(results.length === 3);\n\t\t   for(var i=0; i<results.length; i++) {\n\t\t    test.ok(parseInt(results[i].v1.value) + parseInt(results[i].v2.value) < 5 );\n\t\t}\n\t\ttest.done()\n        }\n    );\n  });\n});\n```\n\n###Persistence\n\nThe store can be persisted in the browser using IndexedDB as the backend. In order to make the store persistent,\nthe 'persistent' flat must be set to true in the store creation options.\nAdditionally, a 'name' option can also be passed for the store. Different persistent instances of the store can be\nopened using different names.\n\n##Dependencies\n\nThe library include dependencies to two semantic-web libraries for\nparsing:\n\n- [N3.js library](https://github.com/RubenVerborgh/N3.js/), developed\n  by Ruben Verborgh and released under the MIT license.\n\n- [jsonld](https://github.com/digitalbazaar/jsonld.js), developed by Digital Bazaar and released under the New BSD license.\n\n##Contributing\n\nrdfstore-js is still at the beginning of its development. If you take a look at the library and find a way to improve it, please ping us. We'll be very greatful for any bug report or pull-request.\n\n## Author\n\nAntonio Garrote, email:antoniogarrote@gmail.com, twitter:@antoniogarrote.\n\n\n## License\n\nLicensed under the [MIT License](http://opensource.org/licenses/MIT), copyright Antonio Garrote 2011-2015\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/antoniogarrote/rdfstore-js/issues"
  },
  "_id": "rdfstore@0.9.4",
  "_from": "rdfstore@0.9.4"
}
